{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoreOS Setup Walkthrough for setting up a CoreOS node as a self-hosted lab box.","title":"CoreOS Setup"},{"location":"#coreos-setup","text":"Walkthrough for setting up a CoreOS node as a self-hosted lab box.","title":"CoreOS Setup"},{"location":"firewall/","text":"Enable firewall After ensuring that the VPN works we're going to disable all access to ssh or any other protocol externally except for http 80 / https 443. That way we can subsequently use Traefik as a reverse proxy into the VPN. For now, let's simply block direct access to SSH. Check the status of the firewall systemctl status -l iptables-restore output core @ghost ~ $ systemctl status - l iptables - restore \u25cf iptables - restore . service - Restore iptables firewall rules Loaded : loaded ( / usr / lib / systemd / system / iptables - restore . service ; disabled ; vendor preset : disabled ) Active : inactive ( dead ) So it's not enabled, let's enable it. sudo systemctl enable iptables-restore We'll now set some rules in / var / lib / iptables / rules - save /var/lib/iptables/rules-save * filter : INPUT DROP [ 0 : 0 ] : FORWARD DROP [ 0 : 0 ] : OUTPUT ACCEPT [ 0 : 0 ] # Accept all loopback ( local ) traffic : - A INPUT - i lo - j ACCEPT # Keep existing connections ( like our SSH session ) alive : - A INPUT - m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT # Accept all TCP / IP traffic to HTTP , and HTTPS ports - A INPUT - p tcp - m tcp --dport 80 -j ACCEPT - A INPUT - p tcp - m tcp --dport 443 -j ACCEPT # Accept all UDP to our VPN - A INPUT - p udp --dport 1194 -j ACCEPT # ( Temporary ) # Accept all TCP / IP to SSH - A INPUT - p tcp - m tcp --dport 22 -j ACCEPT # Accept pings : - A INPUT - p icmp - m icmp --icmp-type 0 -j ACCEPT - A INPUT - p icmp - m icmp --icmp-type 3 -j ACCEPT - A INPUT - p icmp - m icmp --icmp-type 11 -j ACCEPT COMMIT This config: By default: Drops all incoming connection attempts Prevents any forwarding attempts Allows outbound traffic Overrides: Allows ICMP pings and echo responses Allows inbound to http (80) and https (443) Allows inbound udp to our VPN For the moment: Allows inbound to port 22 for ssh Set the right permissions sudo chmod 0644 /var/lib/iptables/rules-save Now we should be ready to try the service again: sudo systemctl start iptables-restore If successful, systemctl will exit silently. We can check the status of the firewall in two ways. First, by using systemctl status: sudo systemctl status -l iptables-restore And secondly by listing the current iptables rules themselves: sudo iptables -v -L current rules example output Chain INPUT ( policy DROP 0 packets , 0 bytes ) pkts bytes target prot opt in out source destination 4 200 ACCEPT all -- lo any anywhere anywhere 69 30530 ACCEPT all -- any any anywhere anywhere ctstate RELATED,ESTABLISHED 0 0 ACCEPT tcp -- any any anywhere anywhere tcp dpt:http 0 0 ACCEPT tcp -- any any anywhere anywhere tcp dpt:https 0 0 ACCEPT udp -- any any anywhere anywhere udp dpt:openvpn 1 64 ACCEPT tcp -- any any anywhere anywhere tcp dpt:ssh 0 0 ACCEPT icmp -- any any anywhere anywhere icmp echo-reply 0 0 ACCEPT icmp -- any any anywhere anywhere icmp destination-unreachable 0 0 ACCEPT icmp -- any any anywhere anywhere icmp time-exceeded All clients on the VPN will be allocated to the 192 . 168 . 255 . 0 / 24 subnet. Hardening the firewall With the above setup and confirmed to work we'll now remove direct external access to SSH. We will though allow from the VPN subnet and localhost. This requires editing the / var / lib / iptables / rules - save file again. Understand local network details Before modifying the firewall we should understand the current network topology. If we want to limit access to host resources (i.e. CoreOS) then we need to appropriately filter network traffic from our docker containers. Some further details available from this StackOverflow question: From inside of a Docker container, how do I connect to the localhost of the machine? host network core @ ns3007580 ~ $ sudo ip addr show docker0 3 : docker0 : < BROADCAST , MULTICAST , UP , LOWER_UP > mtu 1500 qdisc noqueue state UP group default link / ether 02 : 42 : 90 : 8 f : d9 : 1 f brd ff : ff : ff : ff : ff : ff inet 172 . 17 . 0 . 1 / 16 brd 172 . 17 . 255 . 255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80 :: 42 : 90 ff : fe8f : d91f / 64 scope link valid_lft forever preferred_lft forever As you'll see from the above the subnet for docker on the host is 172 . 17 . 0 . 1 / 16 and our host will therefore be 172 . 17 . 0 . 1 . Once connected to the VPN with a client you should be able to connect with a ssh core @172.17.0.1 command. Check this first before proceeding . Modify the firewall sudo vi / var / lib / iptables / rules - save The below diff shows the changes to make - # (Temporary) - # Accept all TCP/IP to SSH - -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT + # Accept all TCP/IP to SSH from VPN subnet + -A INPUT -p tcp -m tcp --dport 22 --src 172.17.0.1/16 -j ACCEPT Warning The next step could permanently lock you out of the system if the previous steps have not been performed correctly... Fair warning! Now reboot and apply the changes made. You shouldn't be able to ssh directly into the box now from an external IP address. sudo shutdown -r now SSH from a connected VPN client should work though. ssh core@172.17.0.1 Configure Docker For a number of reasons we'll enable access to our docker daemon from the VPN subnet. As discussed in the docs the best way to do this is to use a systemd drop-in file. sudo mkdir -p /etc/systemd/system/docker.service.d sudo vi /etc/systemd/system/docker.service.d/override.conf /etc/systemd/system/docker.service.d/override.conf [Service] ExecStart = ExecStart = /usr/bin/dockerd -H fd:// -H tcp://172.17.0.1:2376 Now reload and restart. sudo systemctl daemon-reload sudo systemctl restart docker.service We'll need to modify the firewall again to allow this connection. sudo vi /var/lib/iptables/rules-save # Accept all TCP/IP to SSH from VPN subnet -A INPUT -p tcp -m tcp --dport 22 --src 172 .17.0.1/16 -j ACCEPT -A INPUT -p tcp -m tcp --dport 2376 --src 172 .17.0.1/16 -j ACCEPT Reboot to apply this and now, once connected to the VPN, you should be able to perform the following to set your terminal session to use the remote CoreOS docker daemon. export DOCKER_HOST = tcp://172.17.0.1:2376 docker info docker ps docker info Kernel Version : 4 . 19 . 43 - coreos Operating System : Container Linux by CoreOS 2079 . 4 . 0 ( Rhyolite ) OSType : linux Architecture : x86_64 docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6 b81cbe64109 kylemanna / openvpn : latest \"ovpn_run\" 40 minutes ago Up 40 minutes 0 . 0 . 0 . 0 : 1194 -> 1194 / udp ovpn - ghost","title":"Enable firewall"},{"location":"firewall/#enable-firewall","text":"After ensuring that the VPN works we're going to disable all access to ssh or any other protocol externally except for http 80 / https 443. That way we can subsequently use Traefik as a reverse proxy into the VPN. For now, let's simply block direct access to SSH. Check the status of the firewall systemctl status -l iptables-restore output core @ghost ~ $ systemctl status - l iptables - restore \u25cf iptables - restore . service - Restore iptables firewall rules Loaded : loaded ( / usr / lib / systemd / system / iptables - restore . service ; disabled ; vendor preset : disabled ) Active : inactive ( dead ) So it's not enabled, let's enable it. sudo systemctl enable iptables-restore We'll now set some rules in / var / lib / iptables / rules - save /var/lib/iptables/rules-save * filter : INPUT DROP [ 0 : 0 ] : FORWARD DROP [ 0 : 0 ] : OUTPUT ACCEPT [ 0 : 0 ] # Accept all loopback ( local ) traffic : - A INPUT - i lo - j ACCEPT # Keep existing connections ( like our SSH session ) alive : - A INPUT - m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT # Accept all TCP / IP traffic to HTTP , and HTTPS ports - A INPUT - p tcp - m tcp --dport 80 -j ACCEPT - A INPUT - p tcp - m tcp --dport 443 -j ACCEPT # Accept all UDP to our VPN - A INPUT - p udp --dport 1194 -j ACCEPT # ( Temporary ) # Accept all TCP / IP to SSH - A INPUT - p tcp - m tcp --dport 22 -j ACCEPT # Accept pings : - A INPUT - p icmp - m icmp --icmp-type 0 -j ACCEPT - A INPUT - p icmp - m icmp --icmp-type 3 -j ACCEPT - A INPUT - p icmp - m icmp --icmp-type 11 -j ACCEPT COMMIT This config: By default: Drops all incoming connection attempts Prevents any forwarding attempts Allows outbound traffic Overrides: Allows ICMP pings and echo responses Allows inbound to http (80) and https (443) Allows inbound udp to our VPN For the moment: Allows inbound to port 22 for ssh Set the right permissions sudo chmod 0644 /var/lib/iptables/rules-save Now we should be ready to try the service again: sudo systemctl start iptables-restore If successful, systemctl will exit silently. We can check the status of the firewall in two ways. First, by using systemctl status: sudo systemctl status -l iptables-restore And secondly by listing the current iptables rules themselves: sudo iptables -v -L current rules example output Chain INPUT ( policy DROP 0 packets , 0 bytes ) pkts bytes target prot opt in out source destination 4 200 ACCEPT all -- lo any anywhere anywhere 69 30530 ACCEPT all -- any any anywhere anywhere ctstate RELATED,ESTABLISHED 0 0 ACCEPT tcp -- any any anywhere anywhere tcp dpt:http 0 0 ACCEPT tcp -- any any anywhere anywhere tcp dpt:https 0 0 ACCEPT udp -- any any anywhere anywhere udp dpt:openvpn 1 64 ACCEPT tcp -- any any anywhere anywhere tcp dpt:ssh 0 0 ACCEPT icmp -- any any anywhere anywhere icmp echo-reply 0 0 ACCEPT icmp -- any any anywhere anywhere icmp destination-unreachable 0 0 ACCEPT icmp -- any any anywhere anywhere icmp time-exceeded All clients on the VPN will be allocated to the 192 . 168 . 255 . 0 / 24 subnet.","title":"Enable firewall"},{"location":"firewall/#hardening-the-firewall","text":"With the above setup and confirmed to work we'll now remove direct external access to SSH. We will though allow from the VPN subnet and localhost. This requires editing the / var / lib / iptables / rules - save file again.","title":"Hardening the firewall"},{"location":"firewall/#understand-local-network-details","text":"Before modifying the firewall we should understand the current network topology. If we want to limit access to host resources (i.e. CoreOS) then we need to appropriately filter network traffic from our docker containers. Some further details available from this StackOverflow question: From inside of a Docker container, how do I connect to the localhost of the machine? host network core @ ns3007580 ~ $ sudo ip addr show docker0 3 : docker0 : < BROADCAST , MULTICAST , UP , LOWER_UP > mtu 1500 qdisc noqueue state UP group default link / ether 02 : 42 : 90 : 8 f : d9 : 1 f brd ff : ff : ff : ff : ff : ff inet 172 . 17 . 0 . 1 / 16 brd 172 . 17 . 255 . 255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80 :: 42 : 90 ff : fe8f : d91f / 64 scope link valid_lft forever preferred_lft forever As you'll see from the above the subnet for docker on the host is 172 . 17 . 0 . 1 / 16 and our host will therefore be 172 . 17 . 0 . 1 . Once connected to the VPN with a client you should be able to connect with a ssh core @172.17.0.1 command. Check this first before proceeding .","title":"Understand local network details"},{"location":"firewall/#modify-the-firewall","text":"sudo vi / var / lib / iptables / rules - save The below diff shows the changes to make - # (Temporary) - # Accept all TCP/IP to SSH - -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT + # Accept all TCP/IP to SSH from VPN subnet + -A INPUT -p tcp -m tcp --dport 22 --src 172.17.0.1/16 -j ACCEPT Warning The next step could permanently lock you out of the system if the previous steps have not been performed correctly... Fair warning! Now reboot and apply the changes made. You shouldn't be able to ssh directly into the box now from an external IP address. sudo shutdown -r now SSH from a connected VPN client should work though. ssh core@172.17.0.1","title":"Modify the firewall"},{"location":"firewall/#configure-docker","text":"For a number of reasons we'll enable access to our docker daemon from the VPN subnet. As discussed in the docs the best way to do this is to use a systemd drop-in file. sudo mkdir -p /etc/systemd/system/docker.service.d sudo vi /etc/systemd/system/docker.service.d/override.conf /etc/systemd/system/docker.service.d/override.conf [Service] ExecStart = ExecStart = /usr/bin/dockerd -H fd:// -H tcp://172.17.0.1:2376 Now reload and restart. sudo systemctl daemon-reload sudo systemctl restart docker.service We'll need to modify the firewall again to allow this connection. sudo vi /var/lib/iptables/rules-save # Accept all TCP/IP to SSH from VPN subnet -A INPUT -p tcp -m tcp --dport 22 --src 172 .17.0.1/16 -j ACCEPT -A INPUT -p tcp -m tcp --dport 2376 --src 172 .17.0.1/16 -j ACCEPT Reboot to apply this and now, once connected to the VPN, you should be able to perform the following to set your terminal session to use the remote CoreOS docker daemon. export DOCKER_HOST = tcp://172.17.0.1:2376 docker info docker ps docker info Kernel Version : 4 . 19 . 43 - coreos Operating System : Container Linux by CoreOS 2079 . 4 . 0 ( Rhyolite ) OSType : linux Architecture : x86_64 docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6 b81cbe64109 kylemanna / openvpn : latest \"ovpn_run\" 40 minutes ago Up 40 minutes 0 . 0 . 0 . 0 : 1194 -> 1194 / udp ovpn - ghost","title":"Configure Docker"},{"location":"proxy/","text":"Using Traefik as a reverse proxy Traefik is awesome... It's documented much better elsewhere but, from my perspective it covers off the following requirements: Reverse proxy capabilities (i.e. what you might have used nginx for previously). Routing public facing http : // app . mydomain . com to the equivalent of http : // localhost : 8000 Automatic SSL certificate generation via LetsEncrypt Ability to \"watch\" the docker daemon and, when container changes are detected, it can automatically add their routes and generate new certificates as required. We're going to sit it on ports 80/443, generate a LetsEncrypt trusted certificate and automatically forward all traffic to https. ssh into your CoreOS host ssh core @172.17.0.1 and lets spin it up to illustrate some concepts quickly. # pull the latest image docker pull traefik # now run it with default settings and expose the dashboard # (temporary only, not recommended in production) docker run -d --name traefik -p 80 :80 -p 443 :443 -p 8080 :8080 traefik --api You should now be able to navigate to http://ghost.algebraic.ninja:8080 and see a nice looking (if blank) dashboard. There's nothing in it which is rubbish as we know there's already a container running for our OpenVPN server. We'll kill this instance and change the commandline to mount the docker unix socket from the host into the traefik container to give it access to and context of other containers. # kill the current instance docker rm -f traefik # now append a volume mount docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug But this still isn't enough?? Looking through the logs you'll spot the following: level = debug msg = \"Provider connection established with docker 18.06.3-ce (API 1.38)\" level = debug msg = \"originLabelsmap[org.opencontainers.image.vendor:Containous org.opencontainers.image.version:v1.7.11 org.opencontainers.image.description:A modern reverse-proxy org.opencontainers.image.documentation:https://docs.traefik.io org.opencontainers.image.title:Traefik org.opencontainers.image.url:https://traefik.io]\" level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /traefik \" level = debug msg = \"originLabelsmap[maintainer:Kyle Manna <kyle@kylemanna.com>]\" level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /ovpn-ghost \" level = debug msg = \"Configuration received from provider docker: {}\" level = info msg = \"Server configuration reloaded on :8080\" level = info msg = \"Server configuration reloaded on :80\" What this is telling us is that traefik is detecting the containers but is ignoring them for the moment because we haven't told it how to present them externally using a defined frontend . We need to do this via custom attributes which can be added to those containers at runtime with the following syntax (basic example): traefik . frontend . rule : tell traefik how to know to route incoming traffick to this container. traefik . port : if the rule above is matched, which port on the container to send the matched traffick to. An example would therefore look like this: - \"traefik.frontend.rule=Host:ghost.algebraic.ninja\" - \"traefik.port=80\" This tells Traefik that any incoming connections to a host of ghost . algebraic . ninja should be routed to port 80 on our container. Let's test this with a basic container. docker run - d --name whoami --label traefik.frontend.rule=Host:ghost.algebraic.ninja containous/whoami Now, with the traefik container your logs should show the following... whoami level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /ovpn-ghost \" level = debug msg = \"originLabelsmap[traefik.frontend.rule:Host:ghost.algebraic.ninja]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja]]\" level = debug msg = \"Backend backend-whoami: no load-balancer defined, fallback to 'wrr' method\" level = debug msg = \"Configuration received from provider docker: {\\\"backends\\\":{\\\"backend-whoami\\\":{\\\"servers\\\":{\\\"server-whoami-6a97af237a8c4b33d3b3252f98e273c3\\\":{\\\"url\\\":\\\"http://172.17.0.3:80\\\",\\\"weight\\\":1}},\\\"loadBalancer\\\":{\\\"method\\\":\\\"wrr\\\"}}},\\\"frontends\\\":{\\\"frontend-Host-ghost-algebraic-ninja-0\\\":{\\\"entryPoints\\\":[\\\"http\\\"],\\\"backend\\\":\\\"backend-whoami\\\",\\\"routes\\\":{\\\"route-frontend-Host-ghost-algebraic-ninja-0\\\":{\\\"rule\\\":\\\"Host:ghost.algebraic.ninja\\\"}},\\\"passHostHeader\\\":true,\\\"priority\\\":0,\\\"basicAuth\\\":null}}}\" level = debug msg = \"Wiring frontend frontend-Host-ghost-algebraic-ninja-0 to entryPoint http\" level = debug msg = \"Creating backend backend-whoami\" level = debug msg = \"Adding TLSClientHeaders middleware for frontend frontend-Host-ghost-algebraic-ninja-0\" level = debug msg = \"Creating load-balancer wrr\" level = debug msg = \"Creating server server-whoami-6a97af237a8c4b33d3b3252f98e273c3 at http://172.17.0.3:80 with weight 1\" level = debug msg = \"Creating route route-frontend-Host-ghost-algebraic-ninja-0 Host:ghost.algebraic.ninja\" Navigating to ghost . algebraic . ninja should now show you a load of useful stats about your request and how it's been perceived by the webserver. In addition, navigating to the traefik dashboard that we still have exposed (for now) at ghost . algebraic . ninja : 8080 should show the container. Adding HTTPS For the moment we've purely focused on proxying requests through to the containers. Let's now leverage Traefik's ability to enforce https across all traffick. # kill the old container docker rm -f traefik # start a new one docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" The logs will now show the following: ... level = debug msg = \"Creating entry point redirect http -> https\" ... Navigating to ghost . algebraic . ninja in your browser will display a warning message as it redirects you to a https page. The exact warning will vary by browser but it will be essentially saying it can't verify the authenticity of the webpage. This is because Traefik is serving it up using the default self-signed certificate. logs level = debug msg = \" Serving default cert for request: \\ \" ghost . algebraic . ninja \\ \"\" level = debug msg = \" http: TLS handshake error from 82.24.111.21:53644: EOF \" You can choose to ignore the warning and proceed. Interestingly though you'll see that attempting to access the Traefik dashboard via ghost . algebraic . ninja : 8080 does not get automatically upgraded to SSL. Add a couple of labels to the command to tell traefik to use the / traefik address like a virtual host directory to itself. # kill the old container docker rm -f traefik # start a new one docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ --label \"traefik.frontend.rule=Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" \\ --label \"traefik.port=8080\" \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" Navigating to ghost . algebraic . ninja / traefik will now take you to the dahboard and automatically upgrade the connection to SSL. Adding LetsEncrypt So far we've used the self-signed certificate from Traefik to provide SSL capabilities. Whilst this is probably fine for testing and local development with an externally recognisable domain name we should be able to use the free service from LetsEncrypt to provide a fully-trusted 3 rd party certificate for our web services. More information on this can be found in the ACME section of the Traefik docs. For the moment we will use a basic TLS verification where the authority just verifies that we have an accessible webserver they can handshake with (challenge/response) at the given address by dns. This does not allow wildcard certs though (which we will look at later). # kill the old container docker rm -f traefik # create a storage file for holding the certificates sudo mkdir -p /etc/traefik sudo chown -R core:core /etc/traefik touch /etc/traefik/acme.json sudo chmod 600 /etc/traefik/* # start a new one docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/traefik:/etc/traefik \\ --label \"traefik.frontend.rule=Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" \\ --label \"traefik.port=8080\" \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" \\ --acme \\ --acme.storage = \"/etc/traefik/acme.json\" \\ --acme.email = \"admin@ghost.algebraic.ninja\" \\ --acme.domains = \"ghost.algebraic.ninja\" \\ --acme.entrypoint = \"https\" \\ --acme.tlschallenge \\ --acme.onhostrule The logs will indicate some additional activity now as Traefik identifies the new configuration and then obtains trusted certificates from LetsEncrypt. ACME logs level = debug msg = \"Setting Acme Certificate store from Entrypoint: https\" level = info msg = \"Preparing server traefik &{Address::8080 TLS:<nil> Redirect:<nil> Auth:<nil> WhitelistSourceRange:[] WhiteList:<nil> Compress:false ProxyProtocol:<nil> ForwardedHeaders:0xc00046d080} with readTimeout=0s writeTimeout=0s idleTimeout=3m0s\" level = debug msg = \"Creating entry point redirect http -> https\" level = info msg = \"Preparing server http &{Address::80 TLS:<nil> Redirect:0xc000481600 Auth:<nil> WhitelistSourceRange:[] WhiteList:<nil> Compress:false ProxyProtocol:<nil> ForwardedHeaders:0xc00046ce20} with readTimeout=0s writeTimeout=0s idleTimeout=3m0s\" level = info msg = \"Preparing server https &{Address::443 TLS:0xc000466fc0 Redirect:<nil> Auth:<nil> WhitelistSourceRange:[] WhiteList:<nil> Compress:false ProxyProtocol:<nil> ForwardedHeaders:0xc00046cee0} with readTimeout=0s writeTimeout=0s idleTimeout=3m0s\" level = info msg = \"Starting server on :8080\" level = info msg = \"Starting server on :80\" level = info msg = \"Starting provider configuration.ProviderAggregator {}\" level = info msg = \"Starting server on :443\" level = info msg = \"Starting provider *docker.Provider {\\\"Watch\\\":true,\\\"Filename\\\":\\\"\\\",\\\"Constraints\\\":null,\\\"Trace\\\":false,\\\"TemplateVersion\\\":2,\\\"DebugLogGeneratedTemplate\\\":false,\\\"Endpoint\\\":\\\"unix:///var/run/docker.sock\\\",\\\"Domain\\\":\\\"\\\",\\\"TLS\\\":null,\\\"ExposedByDefault\\\":true,\\\"UseBindPortIP\\\":false,\\\"SwarmMode\\\":false,\\\"Network\\\":\\\"\\\",\\\"SwarmModeRefreshSeconds\\\":15}\" level = info msg = \"Starting provider *acme.Provider {\\\"Email\\\":\\\"admin@ghost.algebraic.ninja\\\",\\\"ACMELogging\\\":false,\\\"CAServer\\\":\\\"https://acme-v02.api.letsencrypt.org/directory\\\",\\\"Storage\\\":\\\"/etc/traefik/acme.json\\\",\\\"EntryPoint\\\":\\\"https\\\",\\\"KeyType\\\":\\\"\\\",\\\"OnHostRule\\\":true,\\\"OnDemand\\\":false,\\\"DNSChallenge\\\":null,\\\"HTTPChallenge\\\":null,\\\"TLSChallenge\\\":{},\\\"Domains\\\":[{\\\"Main\\\":\\\"ghost.algebraic.ninja\\\",\\\"SANs\\\":null}],\\\"Store\\\":{}}\" level = info msg = \"Testing certificate renew...\" level = debug msg = \"Looking for provided certificate(s) to validate [\\\"ghost.algebraic.ninja\\\"]...\" level = debug msg = \"Domains [\\\"ghost.algebraic.ninja\\\"] need ACME certificates generation for domains \\\"ghost.algebraic.ninja\\\".\" level = debug msg = \"Loading ACME certificates [ghost.algebraic.ninja]...\" level = info msg = \"The key type is empty. Use default key type 4096.\" level = debug msg = \"Configuration received from provider ACME: {}\" level = debug msg = \"Provider connection established with docker 18.06.3-ce (API 1.38)\" level = debug msg = \"originLabelsmap[org.opencontainers.image.description:A modern reverse-proxy org.opencontainers.image.documentation:https://docs.traefik.io org.opencontainers.image.title:Traefik org.opencontainers.image.url:https://traefik.io org.opencontainers.image.vendor:Containous org.opencontainers.image.version:v1.7.11 traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080]]\" level = debug msg = \"originLabelsmap[traefik.frontend.rule:Host:ghost.algebraic.ninja]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja]]\" level = debug msg = \"originLabelsmap[maintainer:Kyle Manna <kyle@kylemanna.com>]\" level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /ovpn-ghost \" level = debug msg = \"originLabelsmap[org.opencontainers.image.documentation:https://docs.traefik.io org.opencontainers.image.title:Traefik org.opencontainers.image.url:https://traefik.io org.opencontainers.image.vendor:Containous org.opencontainers.image.version:v1.7.11 traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080 org.opencontainers.image.description:A modern reverse-proxy]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080]]\" level = debug msg = \"originLabelsmap[traefik.frontend.rule:Host:ghost.algebraic.ninja]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja]]\" level = debug msg = \"Backend backend-traefik: no load-balancer defined, fallback to 'wrr' method\" level = debug msg = \"Backend backend-whoami: no load-balancer defined, fallback to 'wrr' method\" level = debug msg = \"Configuration received from provider docker: {\\\"backends\\\":{\\\"backend-traefik\\\":{\\\"servers\\\":{\\\"server-traefik-1604bc8129985bbfcb9fcdde28e4d449\\\":{\\\"url\\\":\\\"http://172.17.0.4:8080\\\",\\\"weight\\\":1}},\\\"loadBalancer\\\":{\\\"method\\\":\\\"wrr\\\"}},\\\"backend-whoami\\\":{\\\"servers\\\":{\\\"server-whoami-6a97af237a8c4b33d3b3252f98e273c3\\\":{\\\"url\\\":\\\"http://172.17.0.3:80\\\",\\\"weight\\\":1}},\\\"loadBalancer\\\":{\\\"method\\\":\\\"wrr\\\"}}},\\\"frontends\\\":{\\\"frontend-Host-ghost-algebraic-ninja-1\\\":{\\\"entryPoints\\\":[\\\"https\\\"],\\\"backend\\\":\\\"backend-whoami\\\",\\\"routes\\\":{\\\"route-frontend-Host-ghost-algebraic-ninja-1\\\":{\\\"rule\\\":\\\"Host:ghost.algebraic.ninja\\\"}},\\\"passHostHeader\\\":true,\\\"priority\\\":0,\\\"basicAuth\\\":null},\\\"frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0\\\":{\\\"entryPoints\\\":[\\\"https\\\"],\\\"backend\\\":\\\"backend-traefik\\\",\\\"routes\\\":{\\\"route-frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0\\\":{\\\"rule\\\":\\\"Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\\\"}},\\\"passHostHeader\\\":true,\\\"priority\\\":0,\\\"basicAuth\\\":null}}}\" level = info msg = \"Server configuration reloaded on :80\" level = info msg = \"Server configuration reloaded on :443\" level = info msg = \"Server configuration reloaded on :8080\" level = debug msg = \"Wiring frontend frontend-Host-ghost-algebraic-ninja-1 to entryPoint https\" level = debug msg = \"Creating backend backend-whoami\" level = debug msg = \"Adding TLSClientHeaders middleware for frontend frontend-Host-ghost-algebraic-ninja-1\" level = debug msg = \"Creating load-balancer wrr\" level = debug msg = \"Creating server server-whoami-6a97af237a8c4b33d3b3252f98e273c3 at http://172.17.0.3:80 with weight 1\" level = debug msg = \"Creating route route-frontend-Host-ghost-algebraic-ninja-1 Host:ghost.algebraic.ninja\" level = debug msg = \"Wiring frontend frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0 to entryPoint https\" level = debug msg = \"Creating backend backend-traefik\" level = debug msg = \"Adding TLSClientHeaders middleware for frontend frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0\" level = debug msg = \"Creating load-balancer wrr\" level = debug msg = \"Creating server server-traefik-1604bc8129985bbfcb9fcdde28e4d449 at http://172.17.0.4:8080 with weight 1\" level = debug msg = \"Creating route route-frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0 Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" level = info msg = \"Server configuration reloaded on :443\" level = info msg = \"Server configuration reloaded on :8080\" level = info msg = \"Server configuration reloaded on :80\" level = debug msg = \"Try to challenge certificate for domain [ghost.algebraic.ninja] founded in Host rule\" level = debug msg = \"Try to challenge certificate for domain [ghost.algebraic.ninja] founded in Host rule\" level = debug msg = \"Looking for provided certificate(s) to validate [\\\"ghost.algebraic.ninja\\\"]...\" level = debug msg = \"No ACME certificate generation required for domains [\\\"ghost.algebraic.ninja\\\"].\" level = debug msg = \"Looking for provided certificate(s) to validate [\\\"ghost.algebraic.ninja\\\"]...\" level = debug msg = \"No ACME certificate generation required for domains [\\\"ghost.algebraic.ninja\\\"].\" level = debug msg = \"Building ACME client...\" level = debug msg = \"https://acme-v02.api.letsencrypt.org/directory\" level = info msg = Register... level = debug msg = \"Using TLS Challenge provider.\" level = debug msg = \"TLS Challenge Present temp certificate for ghost.algebraic.ninja\" level = debug msg = \"TLS Challenge CleanUp temp certificate for ghost.algebraic.ninja\" level = debug msg = \"Certificates obtained for domains [ghost.algebraic.ninja]\" level = debug msg = \"Configuration received from provider ACME: {}\" level = debug msg = \"Adding certificate for domain(s) ghost.algebraic.ninja\" Navigating to ghost . algebraic . ninja / traefik should now present itself with a green tick / trusted certificate signed by the Lets Encrypt Authority . As a result we can now remove the - p 8080 : 8080 from our command as it is no longer required to expose the ports directly to the outside world . As a result our final traefik command looks like this. docker run -d --name traefik \\ -p 80 :80 -p 443 :443 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/traefik:/etc/traefik \\ --label \"traefik.frontend.rule=Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" \\ --label \"traefik.port=8080\" \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" \\ --acme \\ --acme.storage = \"/etc/traefik/acme.json\" \\ --acme.email = \"admin@ghost.algebraic.ninja\" \\ --acme.domains = \"ghost.algebraic.ninja\" \\ --acme.entrypoint = \"https\" \\ --acme.tlschallenge \\ --acme.onhostrule","title":"Using Traefik as a reverse proxy"},{"location":"proxy/#using-traefik-as-a-reverse-proxy","text":"Traefik is awesome... It's documented much better elsewhere but, from my perspective it covers off the following requirements: Reverse proxy capabilities (i.e. what you might have used nginx for previously). Routing public facing http : // app . mydomain . com to the equivalent of http : // localhost : 8000 Automatic SSL certificate generation via LetsEncrypt Ability to \"watch\" the docker daemon and, when container changes are detected, it can automatically add their routes and generate new certificates as required. We're going to sit it on ports 80/443, generate a LetsEncrypt trusted certificate and automatically forward all traffic to https. ssh into your CoreOS host ssh core @172.17.0.1 and lets spin it up to illustrate some concepts quickly. # pull the latest image docker pull traefik # now run it with default settings and expose the dashboard # (temporary only, not recommended in production) docker run -d --name traefik -p 80 :80 -p 443 :443 -p 8080 :8080 traefik --api You should now be able to navigate to http://ghost.algebraic.ninja:8080 and see a nice looking (if blank) dashboard. There's nothing in it which is rubbish as we know there's already a container running for our OpenVPN server. We'll kill this instance and change the commandline to mount the docker unix socket from the host into the traefik container to give it access to and context of other containers. # kill the current instance docker rm -f traefik # now append a volume mount docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug But this still isn't enough?? Looking through the logs you'll spot the following: level = debug msg = \"Provider connection established with docker 18.06.3-ce (API 1.38)\" level = debug msg = \"originLabelsmap[org.opencontainers.image.vendor:Containous org.opencontainers.image.version:v1.7.11 org.opencontainers.image.description:A modern reverse-proxy org.opencontainers.image.documentation:https://docs.traefik.io org.opencontainers.image.title:Traefik org.opencontainers.image.url:https://traefik.io]\" level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /traefik \" level = debug msg = \"originLabelsmap[maintainer:Kyle Manna <kyle@kylemanna.com>]\" level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /ovpn-ghost \" level = debug msg = \"Configuration received from provider docker: {}\" level = info msg = \"Server configuration reloaded on :8080\" level = info msg = \"Server configuration reloaded on :80\" What this is telling us is that traefik is detecting the containers but is ignoring them for the moment because we haven't told it how to present them externally using a defined frontend . We need to do this via custom attributes which can be added to those containers at runtime with the following syntax (basic example): traefik . frontend . rule : tell traefik how to know to route incoming traffick to this container. traefik . port : if the rule above is matched, which port on the container to send the matched traffick to. An example would therefore look like this: - \"traefik.frontend.rule=Host:ghost.algebraic.ninja\" - \"traefik.port=80\" This tells Traefik that any incoming connections to a host of ghost . algebraic . ninja should be routed to port 80 on our container. Let's test this with a basic container. docker run - d --name whoami --label traefik.frontend.rule=Host:ghost.algebraic.ninja containous/whoami Now, with the traefik container your logs should show the following... whoami level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /ovpn-ghost \" level = debug msg = \"originLabelsmap[traefik.frontend.rule:Host:ghost.algebraic.ninja]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja]]\" level = debug msg = \"Backend backend-whoami: no load-balancer defined, fallback to 'wrr' method\" level = debug msg = \"Configuration received from provider docker: {\\\"backends\\\":{\\\"backend-whoami\\\":{\\\"servers\\\":{\\\"server-whoami-6a97af237a8c4b33d3b3252f98e273c3\\\":{\\\"url\\\":\\\"http://172.17.0.3:80\\\",\\\"weight\\\":1}},\\\"loadBalancer\\\":{\\\"method\\\":\\\"wrr\\\"}}},\\\"frontends\\\":{\\\"frontend-Host-ghost-algebraic-ninja-0\\\":{\\\"entryPoints\\\":[\\\"http\\\"],\\\"backend\\\":\\\"backend-whoami\\\",\\\"routes\\\":{\\\"route-frontend-Host-ghost-algebraic-ninja-0\\\":{\\\"rule\\\":\\\"Host:ghost.algebraic.ninja\\\"}},\\\"passHostHeader\\\":true,\\\"priority\\\":0,\\\"basicAuth\\\":null}}}\" level = debug msg = \"Wiring frontend frontend-Host-ghost-algebraic-ninja-0 to entryPoint http\" level = debug msg = \"Creating backend backend-whoami\" level = debug msg = \"Adding TLSClientHeaders middleware for frontend frontend-Host-ghost-algebraic-ninja-0\" level = debug msg = \"Creating load-balancer wrr\" level = debug msg = \"Creating server server-whoami-6a97af237a8c4b33d3b3252f98e273c3 at http://172.17.0.3:80 with weight 1\" level = debug msg = \"Creating route route-frontend-Host-ghost-algebraic-ninja-0 Host:ghost.algebraic.ninja\" Navigating to ghost . algebraic . ninja should now show you a load of useful stats about your request and how it's been perceived by the webserver. In addition, navigating to the traefik dashboard that we still have exposed (for now) at ghost . algebraic . ninja : 8080 should show the container.","title":"Using Traefik as a reverse proxy"},{"location":"proxy/#adding-https","text":"For the moment we've purely focused on proxying requests through to the containers. Let's now leverage Traefik's ability to enforce https across all traffick. # kill the old container docker rm -f traefik # start a new one docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" The logs will now show the following: ... level = debug msg = \"Creating entry point redirect http -> https\" ... Navigating to ghost . algebraic . ninja in your browser will display a warning message as it redirects you to a https page. The exact warning will vary by browser but it will be essentially saying it can't verify the authenticity of the webpage. This is because Traefik is serving it up using the default self-signed certificate. logs level = debug msg = \" Serving default cert for request: \\ \" ghost . algebraic . ninja \\ \"\" level = debug msg = \" http: TLS handshake error from 82.24.111.21:53644: EOF \" You can choose to ignore the warning and proceed. Interestingly though you'll see that attempting to access the Traefik dashboard via ghost . algebraic . ninja : 8080 does not get automatically upgraded to SSL. Add a couple of labels to the command to tell traefik to use the / traefik address like a virtual host directory to itself. # kill the old container docker rm -f traefik # start a new one docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ --label \"traefik.frontend.rule=Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" \\ --label \"traefik.port=8080\" \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" Navigating to ghost . algebraic . ninja / traefik will now take you to the dahboard and automatically upgrade the connection to SSL.","title":"Adding HTTPS"},{"location":"proxy/#adding-letsencrypt","text":"So far we've used the self-signed certificate from Traefik to provide SSL capabilities. Whilst this is probably fine for testing and local development with an externally recognisable domain name we should be able to use the free service from LetsEncrypt to provide a fully-trusted 3 rd party certificate for our web services. More information on this can be found in the ACME section of the Traefik docs. For the moment we will use a basic TLS verification where the authority just verifies that we have an accessible webserver they can handshake with (challenge/response) at the given address by dns. This does not allow wildcard certs though (which we will look at later). # kill the old container docker rm -f traefik # create a storage file for holding the certificates sudo mkdir -p /etc/traefik sudo chown -R core:core /etc/traefik touch /etc/traefik/acme.json sudo chmod 600 /etc/traefik/* # start a new one docker run -d --name traefik \\ -p 80 :80 -p 443 :443 -p 8080 :8080 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/traefik:/etc/traefik \\ --label \"traefik.frontend.rule=Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" \\ --label \"traefik.port=8080\" \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" \\ --acme \\ --acme.storage = \"/etc/traefik/acme.json\" \\ --acme.email = \"admin@ghost.algebraic.ninja\" \\ --acme.domains = \"ghost.algebraic.ninja\" \\ --acme.entrypoint = \"https\" \\ --acme.tlschallenge \\ --acme.onhostrule The logs will indicate some additional activity now as Traefik identifies the new configuration and then obtains trusted certificates from LetsEncrypt. ACME logs level = debug msg = \"Setting Acme Certificate store from Entrypoint: https\" level = info msg = \"Preparing server traefik &{Address::8080 TLS:<nil> Redirect:<nil> Auth:<nil> WhitelistSourceRange:[] WhiteList:<nil> Compress:false ProxyProtocol:<nil> ForwardedHeaders:0xc00046d080} with readTimeout=0s writeTimeout=0s idleTimeout=3m0s\" level = debug msg = \"Creating entry point redirect http -> https\" level = info msg = \"Preparing server http &{Address::80 TLS:<nil> Redirect:0xc000481600 Auth:<nil> WhitelistSourceRange:[] WhiteList:<nil> Compress:false ProxyProtocol:<nil> ForwardedHeaders:0xc00046ce20} with readTimeout=0s writeTimeout=0s idleTimeout=3m0s\" level = info msg = \"Preparing server https &{Address::443 TLS:0xc000466fc0 Redirect:<nil> Auth:<nil> WhitelistSourceRange:[] WhiteList:<nil> Compress:false ProxyProtocol:<nil> ForwardedHeaders:0xc00046cee0} with readTimeout=0s writeTimeout=0s idleTimeout=3m0s\" level = info msg = \"Starting server on :8080\" level = info msg = \"Starting server on :80\" level = info msg = \"Starting provider configuration.ProviderAggregator {}\" level = info msg = \"Starting server on :443\" level = info msg = \"Starting provider *docker.Provider {\\\"Watch\\\":true,\\\"Filename\\\":\\\"\\\",\\\"Constraints\\\":null,\\\"Trace\\\":false,\\\"TemplateVersion\\\":2,\\\"DebugLogGeneratedTemplate\\\":false,\\\"Endpoint\\\":\\\"unix:///var/run/docker.sock\\\",\\\"Domain\\\":\\\"\\\",\\\"TLS\\\":null,\\\"ExposedByDefault\\\":true,\\\"UseBindPortIP\\\":false,\\\"SwarmMode\\\":false,\\\"Network\\\":\\\"\\\",\\\"SwarmModeRefreshSeconds\\\":15}\" level = info msg = \"Starting provider *acme.Provider {\\\"Email\\\":\\\"admin@ghost.algebraic.ninja\\\",\\\"ACMELogging\\\":false,\\\"CAServer\\\":\\\"https://acme-v02.api.letsencrypt.org/directory\\\",\\\"Storage\\\":\\\"/etc/traefik/acme.json\\\",\\\"EntryPoint\\\":\\\"https\\\",\\\"KeyType\\\":\\\"\\\",\\\"OnHostRule\\\":true,\\\"OnDemand\\\":false,\\\"DNSChallenge\\\":null,\\\"HTTPChallenge\\\":null,\\\"TLSChallenge\\\":{},\\\"Domains\\\":[{\\\"Main\\\":\\\"ghost.algebraic.ninja\\\",\\\"SANs\\\":null}],\\\"Store\\\":{}}\" level = info msg = \"Testing certificate renew...\" level = debug msg = \"Looking for provided certificate(s) to validate [\\\"ghost.algebraic.ninja\\\"]...\" level = debug msg = \"Domains [\\\"ghost.algebraic.ninja\\\"] need ACME certificates generation for domains \\\"ghost.algebraic.ninja\\\".\" level = debug msg = \"Loading ACME certificates [ghost.algebraic.ninja]...\" level = info msg = \"The key type is empty. Use default key type 4096.\" level = debug msg = \"Configuration received from provider ACME: {}\" level = debug msg = \"Provider connection established with docker 18.06.3-ce (API 1.38)\" level = debug msg = \"originLabelsmap[org.opencontainers.image.description:A modern reverse-proxy org.opencontainers.image.documentation:https://docs.traefik.io org.opencontainers.image.title:Traefik org.opencontainers.image.url:https://traefik.io org.opencontainers.image.vendor:Containous org.opencontainers.image.version:v1.7.11 traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080]]\" level = debug msg = \"originLabelsmap[traefik.frontend.rule:Host:ghost.algebraic.ninja]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja]]\" level = debug msg = \"originLabelsmap[maintainer:Kyle Manna <kyle@kylemanna.com>]\" level = debug msg = \"allLabelsmap[:map[]]\" level = debug msg = \"Filtering container with empty frontend rule /ovpn-ghost \" level = debug msg = \"originLabelsmap[org.opencontainers.image.documentation:https://docs.traefik.io org.opencontainers.image.title:Traefik org.opencontainers.image.url:https://traefik.io org.opencontainers.image.vendor:Containous org.opencontainers.image.version:v1.7.11 traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080 org.opencontainers.image.description:A modern reverse-proxy]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik traefik.port:8080]]\" level = debug msg = \"originLabelsmap[traefik.frontend.rule:Host:ghost.algebraic.ninja]\" level = debug msg = \"allLabelsmap[:map[traefik.frontend.rule:Host:ghost.algebraic.ninja]]\" level = debug msg = \"Backend backend-traefik: no load-balancer defined, fallback to 'wrr' method\" level = debug msg = \"Backend backend-whoami: no load-balancer defined, fallback to 'wrr' method\" level = debug msg = \"Configuration received from provider docker: {\\\"backends\\\":{\\\"backend-traefik\\\":{\\\"servers\\\":{\\\"server-traefik-1604bc8129985bbfcb9fcdde28e4d449\\\":{\\\"url\\\":\\\"http://172.17.0.4:8080\\\",\\\"weight\\\":1}},\\\"loadBalancer\\\":{\\\"method\\\":\\\"wrr\\\"}},\\\"backend-whoami\\\":{\\\"servers\\\":{\\\"server-whoami-6a97af237a8c4b33d3b3252f98e273c3\\\":{\\\"url\\\":\\\"http://172.17.0.3:80\\\",\\\"weight\\\":1}},\\\"loadBalancer\\\":{\\\"method\\\":\\\"wrr\\\"}}},\\\"frontends\\\":{\\\"frontend-Host-ghost-algebraic-ninja-1\\\":{\\\"entryPoints\\\":[\\\"https\\\"],\\\"backend\\\":\\\"backend-whoami\\\",\\\"routes\\\":{\\\"route-frontend-Host-ghost-algebraic-ninja-1\\\":{\\\"rule\\\":\\\"Host:ghost.algebraic.ninja\\\"}},\\\"passHostHeader\\\":true,\\\"priority\\\":0,\\\"basicAuth\\\":null},\\\"frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0\\\":{\\\"entryPoints\\\":[\\\"https\\\"],\\\"backend\\\":\\\"backend-traefik\\\",\\\"routes\\\":{\\\"route-frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0\\\":{\\\"rule\\\":\\\"Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\\\"}},\\\"passHostHeader\\\":true,\\\"priority\\\":0,\\\"basicAuth\\\":null}}}\" level = info msg = \"Server configuration reloaded on :80\" level = info msg = \"Server configuration reloaded on :443\" level = info msg = \"Server configuration reloaded on :8080\" level = debug msg = \"Wiring frontend frontend-Host-ghost-algebraic-ninja-1 to entryPoint https\" level = debug msg = \"Creating backend backend-whoami\" level = debug msg = \"Adding TLSClientHeaders middleware for frontend frontend-Host-ghost-algebraic-ninja-1\" level = debug msg = \"Creating load-balancer wrr\" level = debug msg = \"Creating server server-whoami-6a97af237a8c4b33d3b3252f98e273c3 at http://172.17.0.3:80 with weight 1\" level = debug msg = \"Creating route route-frontend-Host-ghost-algebraic-ninja-1 Host:ghost.algebraic.ninja\" level = debug msg = \"Wiring frontend frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0 to entryPoint https\" level = debug msg = \"Creating backend backend-traefik\" level = debug msg = \"Adding TLSClientHeaders middleware for frontend frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0\" level = debug msg = \"Creating load-balancer wrr\" level = debug msg = \"Creating server server-traefik-1604bc8129985bbfcb9fcdde28e4d449 at http://172.17.0.4:8080 with weight 1\" level = debug msg = \"Creating route route-frontend-Host-ghost-algebraic-ninja-PathPrefixStrip-traefik-0 Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" level = info msg = \"Server configuration reloaded on :443\" level = info msg = \"Server configuration reloaded on :8080\" level = info msg = \"Server configuration reloaded on :80\" level = debug msg = \"Try to challenge certificate for domain [ghost.algebraic.ninja] founded in Host rule\" level = debug msg = \"Try to challenge certificate for domain [ghost.algebraic.ninja] founded in Host rule\" level = debug msg = \"Looking for provided certificate(s) to validate [\\\"ghost.algebraic.ninja\\\"]...\" level = debug msg = \"No ACME certificate generation required for domains [\\\"ghost.algebraic.ninja\\\"].\" level = debug msg = \"Looking for provided certificate(s) to validate [\\\"ghost.algebraic.ninja\\\"]...\" level = debug msg = \"No ACME certificate generation required for domains [\\\"ghost.algebraic.ninja\\\"].\" level = debug msg = \"Building ACME client...\" level = debug msg = \"https://acme-v02.api.letsencrypt.org/directory\" level = info msg = Register... level = debug msg = \"Using TLS Challenge provider.\" level = debug msg = \"TLS Challenge Present temp certificate for ghost.algebraic.ninja\" level = debug msg = \"TLS Challenge CleanUp temp certificate for ghost.algebraic.ninja\" level = debug msg = \"Certificates obtained for domains [ghost.algebraic.ninja]\" level = debug msg = \"Configuration received from provider ACME: {}\" level = debug msg = \"Adding certificate for domain(s) ghost.algebraic.ninja\" Navigating to ghost . algebraic . ninja / traefik should now present itself with a green tick / trusted certificate signed by the Lets Encrypt Authority . As a result we can now remove the - p 8080 : 8080 from our command as it is no longer required to expose the ports directly to the outside world . As a result our final traefik command looks like this. docker run -d --name traefik \\ -p 80 :80 -p 443 :443 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/traefik:/etc/traefik \\ --label \"traefik.frontend.rule=Host:ghost.algebraic.ninja; PathPrefixStrip: /traefik\" \\ --label \"traefik.port=8080\" \\ traefik --api --docker --docker.watch \\ --docker.endpoint = \"unix:///var/run/docker.sock\" \\ --docker.exposedbydefault \\ --loglevel = debug \\ --defaultentrypoints = \"https\" \\ --entryPoints = \"Name:http Address::80 Redirect.EntryPoint:https\" \\ --entryPoints = \"Name:https Address::443 TLS\" \\ --acme \\ --acme.storage = \"/etc/traefik/acme.json\" \\ --acme.email = \"admin@ghost.algebraic.ninja\" \\ --acme.domains = \"ghost.algebraic.ninja\" \\ --acme.entrypoint = \"https\" \\ --acme.tlschallenge \\ --acme.onhostrule","title":"Adding LetsEncrypt"},{"location":"vpn/","text":"Setting up OpenVPN Server on CoreOS Due to issues with getting wireguard working reverting to OpenVPN via kylemanna/docker-openvpn . I'm going to assume a domain of ghost . algebraic . ninja First, create the data volume. OVPN_DATA = \"ovpn-data-ghost\" docker volume create --name $OVPN_DATA Now show the details for reference with docker volume inspect $ OVPN_DATA example output [ { \"CreatedAt\": \"2019-05-22T20:00:38Z\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/ovpn-data-ghost/_data\", \"Name\": \"ovpn-data-ghost\", \"Options\": {}, \"Scope\": \"local\" } ] Next we'll initialise the $ OVPN_DATA container that will hold the configuration files and certificates. The container will prompt for a passphrase to protect the private key used by the newly generated certificate authority. VPN_HOST = ghost.algebraic.ninja docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm kylemanna/openvpn ovpn_genconfig -u udp:// $VPN_HOST config output Status : Downloaded newer image for kylemanna / openvpn : latest Processing PUSH Config : ' block-outside-dns ' Processing Route Config : ' 192.168.254.0/24 ' Processing PUSH Config : ' dhcp-option DNS 8.8.8.8 ' Processing PUSH Config : ' dhcp-option DNS 8.8.4.4 ' Processing PUSH Config : ' comp-lzo no ' Successfully generated config Cleaning up before Exit ... Initialise the PKI docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm -it kylemanna/openvpn ovpn_initpki Start OpenVPN server process docker run -v $OVPN_DATA :/etc/openvpn -d -p 1194 :1194/udp --cap-add = NET_ADMIN kylemanna/openvpn Generate a client certificate without a passphrase CLIENTNAME = jamesveitch docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm -it kylemanna/openvpn easyrsa build-client-full $CLIENTNAME nopass Retrieve the client configuration with embedded certificates docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm kylemanna/openvpn ovpn_getclient $CLIENTNAME > $CLIENTNAME .ovpn Now add it as a systemd service on reboot. Download the docker-openvpn@.service file to /etc/systemd/system: curl -L https://raw.githubusercontent.com/kylemanna/docker-openvpn/master/init/docker-openvpn%40.service | sudo tee /etc/systemd/system/docker-openvpn@.service Enable and start the service with: systemctl enable --now docker-openvpn@ghost.service","title":"Setting up OpenVPN Server on CoreOS"},{"location":"vpn/#setting-up-openvpn-server-on-coreos","text":"Due to issues with getting wireguard working reverting to OpenVPN via kylemanna/docker-openvpn . I'm going to assume a domain of ghost . algebraic . ninja First, create the data volume. OVPN_DATA = \"ovpn-data-ghost\" docker volume create --name $OVPN_DATA Now show the details for reference with docker volume inspect $ OVPN_DATA example output [ { \"CreatedAt\": \"2019-05-22T20:00:38Z\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/ovpn-data-ghost/_data\", \"Name\": \"ovpn-data-ghost\", \"Options\": {}, \"Scope\": \"local\" } ] Next we'll initialise the $ OVPN_DATA container that will hold the configuration files and certificates. The container will prompt for a passphrase to protect the private key used by the newly generated certificate authority. VPN_HOST = ghost.algebraic.ninja docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm kylemanna/openvpn ovpn_genconfig -u udp:// $VPN_HOST config output Status : Downloaded newer image for kylemanna / openvpn : latest Processing PUSH Config : ' block-outside-dns ' Processing Route Config : ' 192.168.254.0/24 ' Processing PUSH Config : ' dhcp-option DNS 8.8.8.8 ' Processing PUSH Config : ' dhcp-option DNS 8.8.4.4 ' Processing PUSH Config : ' comp-lzo no ' Successfully generated config Cleaning up before Exit ... Initialise the PKI docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm -it kylemanna/openvpn ovpn_initpki Start OpenVPN server process docker run -v $OVPN_DATA :/etc/openvpn -d -p 1194 :1194/udp --cap-add = NET_ADMIN kylemanna/openvpn Generate a client certificate without a passphrase CLIENTNAME = jamesveitch docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm -it kylemanna/openvpn easyrsa build-client-full $CLIENTNAME nopass Retrieve the client configuration with embedded certificates docker run -v $OVPN_DATA :/etc/openvpn --log-driver = none --rm kylemanna/openvpn ovpn_getclient $CLIENTNAME > $CLIENTNAME .ovpn Now add it as a systemd service on reboot. Download the docker-openvpn@.service file to /etc/systemd/system: curl -L https://raw.githubusercontent.com/kylemanna/docker-openvpn/master/init/docker-openvpn%40.service | sudo tee /etc/systemd/system/docker-openvpn@.service Enable and start the service with: systemctl enable --now docker-openvpn@ghost.service","title":"Setting up OpenVPN Server on CoreOS"}]}